package info

import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/labstack/echo/v4"
	"github.com/spf13/cobra"

	"github.com/codoworks/codo-framework/cmd"
	"github.com/codoworks/codo-framework/core/app"
	"github.com/codoworks/codo-framework/core/http"
)

var scopeFilter string

var routesCmd = &cobra.Command{
	Use:   "routes",
	Short: "Show registered routes",
	Long:  "Display all registered HTTP handlers and their routes",
	RunE: func(c *cobra.Command, args []string) error {
		cfg := cmd.GetConfig()

		// Get bootstrap options from registered initializer
		var opts app.BootstrapOptions
		if initializer := app.GetInitializer(); initializer != nil {
			var err error
			opts, err = initializer(cfg)
			if err != nil {
				return fmt.Errorf("initialization failed: %w", err)
			}
		}

		// Set mode for this command
		opts.Mode = app.RouteInspector

		// Bootstrap application (creates server but doesn't start it)
		application, err := app.Bootstrap(cfg, opts)
		if err != nil {
			return fmt.Errorf("bootstrap failed: %w", err)
		}
		defer application.Shutdown(context.Background())

		// Type assert to HTTPApp and get server (routes already prepared by bootstrap)
		httpApp, ok := application.(app.HTTPApp)
		if !ok {
			return fmt.Errorf("expected HTTPApp, got %T", application)
		}
		server := httpApp.Server()

		out := cmd.GetOutput()
		httpHandlers := http.AllHandlers()

		if scopeFilter != "" {
			scope, err := http.ParseScope(scopeFilter)
			if err != nil {
				return fmt.Errorf("invalid scope: %s (must be public, protected, or hidden)", scopeFilter)
			}
			httpHandlers = http.GetHandlers(scope)
		}

		if len(httpHandlers) == 0 {
			fmt.Fprintln(out, "No handlers registered")
			return nil
		}

		// Header
		fmt.Fprintf(out, "%-12s %-40s\n", "SCOPE", "PREFIX")
		fmt.Fprintln(out, strings.Repeat("-", 54))

		// For each handler, show prefix and detailed routes
		for _, h := range httpHandlers {
			// Print handler prefix
			fmt.Fprintf(out, "%-12s %-40s\n", h.Scope(), h.Prefix())

			// Get router for this scope
			router := server.Router(h.Scope())
			if router == nil {
				continue
			}

			// Get all routes from this router
			routes := router.Routes()

			// Filter routes that belong to this handler (match prefix)
			var handlerRoutes []*echo.Route
			for _, route := range routes {
				if strings.HasPrefix(route.Path, h.Prefix()) {
					handlerRoutes = append(handlerRoutes, route)
				}
			}

			// Sort routes by path, then by method
			sortRoutes(handlerRoutes)

			// Display each route with indentation
			for _, route := range handlerRoutes {
				// Skip HEAD routes (auto-generated by Echo for GET)
				if route.Method == "HEAD" {
					continue
				}
				fmt.Fprintf(out, "             %-7s %s\n", route.Method, route.Path)
			}

			fmt.Fprintln(out) // Blank line between handlers
		}

		return nil
	},
}

// ResetRoutesFlags resets routes command flags (for testing)
func ResetRoutesFlags() {
	scopeFilter = ""
}

// sortRoutes sorts routes by path (primary) and method (secondary)
func sortRoutes(routes []*echo.Route) {
	sort.Slice(routes, func(i, j int) bool {
		if routes[i].Path == routes[j].Path {
			// If paths are the same, sort by method (GET, POST, PUT, PATCH, DELETE)
			methodOrder := map[string]int{
				"GET":    0,
				"POST":   1,
				"PUT":    2,
				"PATCH":  3,
				"DELETE": 4,
			}
			orderI, okI := methodOrder[routes[i].Method]
			orderJ, okJ := methodOrder[routes[j].Method]
			if okI && okJ {
				return orderI < orderJ
			}
			// Fallback to alphabetical for unknown methods
			return routes[i].Method < routes[j].Method
		}
		return routes[i].Path < routes[j].Path
	})
}

func init() {
	routesCmd.Flags().StringVar(&scopeFilter, "scope", "", "filter by scope (public, protected, hidden)")
	cmd.AddInfoCommand(routesCmd)
}
